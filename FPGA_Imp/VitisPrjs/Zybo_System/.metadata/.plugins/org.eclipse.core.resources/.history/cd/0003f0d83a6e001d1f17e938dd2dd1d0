#include "PS2.hpp"
#include "GPIO.hpp"

static XScuGic InterruptController;
static XGpio   GPIOInterruptController;
XScuGic *myInterruptPtr = &InterruptController;
XScuGic_Config *myIntConfig;
XGpio myGPIOInterruptPtr; /* don't question why this is not a pointer.. XGpio is dumb */

void GPIO_InterruptHandler(void *IntcInstancePtr){
	int btn_value = 0;

	// Disable GPIO interrupts
	XGpio_InterruptDisable(&GpioBtn, XGPIO_IR_CH1_MASK);

	// Ignore additional button presses
	if ((XGpio_InterruptGetStatus(&GpioBtn) & XGPIO_IR_CH1_MASK) !=XGPIO_IR_CH1_MASK) {
		return;
	}
	btn_value = XGpio_DiscreteRead(&GpioBtn, 1); // Channel 1
	if (btn_value == 1) {   // Case 0
		std::cout<<"Hey"<<std::endl;
	}
	else if (btn_value == 2) { // Case 1
		std::cout<<"Hey"<<std::endl;
	}
	else if (btn_value == 4) { // Case 2
		std::cout<<"Hey"<<std::endl;
	}
	else if (btn_value == 8) { // Case 3
		std::cout<<"Hey"<<std::endl;
	}
	(void) XGpio_InterruptClear(&GpioBtn, XGPIO_IR_CH1_MASK);
	// Enable GPIO interrupts
	XGpio_InterruptEnable(&GpioBtn, XGPIO_IR_CH1_MASK);
}


// Change this to decide what happens when a key is pressed.
void Keyboard_InterruptHandler(void *IntcInstancePtr){
	//char break_data[2];
	//u32 ascii_data = Xil_In32(PS2_Keyboard_Base) & PS2_Data_Mask;
	//itoa(Xil_In32(PS2_Keyboard_Base) >> PS2_Break_Shift,break_data,2);
	// Print ASCII Character
	xil_printf("ascii: %s \n\r",PS2_ReadDataASCII(PS2_Keyboard_Base));
	xil_printf("break: %d \n\r",(int)PS2_ReadBreak(PS2_Keyboard_Base));
	xil_printf("time: %d \n\r",PS2_ReadTime(PS2_Keyboard_Base));
}



int Interrupt_Init(u32 PS2_INT_ID,u32 GPIO_INT_ID,u32 GPIO_INT_CHANNEL){
	int Status;
	std::cout << "here0"<<std::endl;
	GPIO_Init(&myGPIOInterruptPtr,BTN_DEVICE_ID);
	//XGpio_SetDataDirection(myGPIOInterruptPtr, 1,0xFF); // Set all buttons to inputs



	std::cout << "here1"<<std::endl;
	// Grab Interrupt Controller Config
	myIntConfig = XScuGic_LookupConfig(XPAR_PS7_SCUGIC_0_DEVICE_ID);
	// Initialize Interrupt Controller Driver
	Status = XScuGic_CfgInitialize(myInterruptPtr,myIntConfig,myIntConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS){
		return Status;
	}
	std::cout << "here2"<<std::endl;
	////////////////// GPIO (Has its only Interrupt controller) ////////////////////
	XGpio_InterruptEnable(&myGPIOInterruptPtr,1);
	std::cout << "here31"<<std::endl;
	XGpio_InterruptGlobalEnable(&myGPIOInterruptPtr);
	std::cout << "here32"<<std::endl;
	// Connect to Function
	Status = XScuGic_Connect(myInterruptPtr,GPIO_INT_ID,(Xil_ExceptionHandler)GPIO_InterruptHandler,(void *)&GPIOInterruptController);
	if (Status != XST_SUCCESS){
		return Status;
	}
	std::cout << "here3"<<std::endl;
	// Enable GPIO interrupts interrupt
	XGpio_InterruptEnable(&myGPIOInterruptPtr,GPIO_INT_CHANNEL);
	std::cout << "here4"<<std::endl;
	XGpio_InterruptGlobalEnable(&myGPIOInterruptPtr);
	std::cout << "here5"<<std::endl;
	// Enable GPIO interrupts in the controller
	XScuGic_Enable(myInterruptPtr,GPIO_INT_ID);
	////////////////////////////////////////////////////////////////////////////////

	////////////////// PS2 (Can use XScuGic) ///////////////////////////////////////
	// set the priority of IRQ_F2P[0:0] (highest 0x00, lowest 0xF8) and a trigger for a rising edge 0x3.
	XScuGic_SetPriorityTriggerType(myInterruptPtr, PS2_INT_ID, 0x00, 0x3);
	std::cout << "here6"<<std::endl;
	// connect the interrupt service routine isr0 to the interrupt controller
	Status = XScuGic_Connect(myInterruptPtr, PS2_INT_ID, (Xil_ExceptionHandler)Keyboard_InterruptHandler, (void *)&InterruptController);
	if (Status != XST_SUCCESS) {
		return Status;
	}
	std::cout << "here7"<<std::endl;
	// enable interrupt
	XScuGic_Enable(myInterruptPtr, PS2_INT_ID);
	////////////////////////////////////////////////////////////////////////////////
	std::cout << "here8"<<std::endl;
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler) XScuGic_InterruptHandler,myInterruptPtr);
	std::cout << "here9"<<std::endl;
	Xil_ExceptionEnable();
	std::cout << "here10"<<std::endl;


	return XST_SUCCESS;
}


// Set up Interrupts for PS2
// priority = 0x00 to 0xF8, 0x00 highest, trigger = 0x3 -> rising edge. Unknown others atm
//int PS2_IntSetup(u32 PS2_INT_ID, u32 priority,u32 trigger) {
//
//    int Status;
//    XScuGic *IntcInstancePtr = &InterruptController;
//    XScuGic_Config *intc_config;
//
//    // get config for interrupt controller
//    intc_config = XScuGic_LookupConfig(XPAR_PS7_SCUGIC_0_DEVICE_ID);
//    if (NULL == intc_config) {
//        return XST_FAILURE;
//    }
//
//    // initialize the interrupt controller driver
//    Status = XScuGic_CfgInitialize(IntcInstancePtr, intc_config, intc_config->CpuBaseAddress);
//
//    if (Status != XST_SUCCESS) {
//        return Status;
//    }
//
//
//    ///// PS2 Interrupt ///////////////////
//    // set the priority of IRQ_F2P[0:0] (highest 0x00, lowest 0xF8) and a trigger for a rising edge 0x3.
//    XScuGic_SetPriorityTriggerType(IntcInstancePtr, PS2_INT_ID, priority, trigger);
//
//    // connect the interrupt service routine isr0 to the interrupt controller
//    Status = XScuGic_Connect(IntcInstancePtr, PS2_INT_ID, (Xil_ExceptionHandler)Keyboard_InterruptHandler, (void *)&InterruptController);
//
//    if (Status != XST_SUCCESS) {
//        return Status;
//    }
//
//    // enable interrupts for IRQ_F2P[0:0]
//    XScuGic_Enable(IntcInstancePtr, PS2_INT_ID);
//    ///////////////////////////////////////
//// EXAMPLE FOR A 2ND INPUT
//    // set the priority of IRQ_F2P[1:1] to 0xA8 (highest 0x00, lowest 0xF8) and a trigger for a rising edge 0x3.
//    XScuGic_SetPriorityTriggerType(IntcInstancePtr, 62, 0x00, 0x3);
//
//    // connect the interrupt service routine isr1 to the interrupt controller
//    Status = XScuGic_Connect(IntcInstancePtr, 62, (Xil_ExceptionHandler)Button_InterruptHandler, (void *)&InterruptController);
//
//    if (Status != XST_SUCCESS) {
//        return Status;
//    }
//
//    // enable interrupts for IRQ_F2P[1:1]
//    XScuGic_Enable(IntcInstancePtr, 62);
//
//    // initialize the exception table and register the interrupt controller handler with the exception table
//    Xil_ExceptionInit();
//
//    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, IntcInstancePtr);
//
//    // enable non-critical exceptions
//    Xil_ExceptionEnable();
//
//    return XST_SUCCESS;
//}
